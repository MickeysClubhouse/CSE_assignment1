1:Task
Your task is to write a program that understands the Unix v6 file system to extract the file system data.

You can visually compare your output to that generated by my own solution by typing
$  ./samples/diskimageaccess_soln ​<options>​ ​<diskimagePath>

diskimagePath ​should be the path to one of the test disks located in:
$ /usr/​class​/cs110/​samples​/assign2/​testdisks​
We currently have three test disks:
basicDiskImage​, ​depthFileDiskImage​ and dirFnameSizeDiskImage​

diskimageaccess ​recognizes two flags as valid ​<options>​: 
   -i​:testtheinodeandfilelayers
   -p​:testthefilenameandpathnamelayers

For example, to run both the inode and filename tests on the basic disk, you could run:
$ ln -s /usr/class/cs110/samples/assign2/testdisks testdisks 
$ ./diskimageaccess -ip testdisks/basicDiskImage

The expected output for running ​diskimageaccess ​on each disk image ​X ​is stored in the ​X.gold file inside the ​testdisks ​directory. 
In fact, we’re leveraging even another CS107 tool: the sanitycheck ​tool, which you can read about ​right here​.
In particular, if you type:
$ ./tools/sanitycheck
at the command prompt while in your ​assign2 ​directory, the ​sanitycheck ​script will exercise your implementation in precisely the 
same way our own grading scripts will. We won’t always expose all of the functionality tests, but we are for Assignment 2.

2:Supplement

The files we provide you fall into three categories.
The Version 6 Unix header files (filsys.h,ino.h,direntv6.h)
These are described below.
The test harness (diskimageaccess.c,chksumfile.[ch],unixfilesystems.[ch])
These files provide the infrastructure for building your code and running our tests against it.

File system module (diskimg.[ch],inode.[ch], file.[ch], pathname.[ch])
The test code we give you interfaces with the file system using a layered API that we've already designed. For each of the layers 
that you'll need to implement for this assignment, there is a header file that defines the interface to the layer and a corresponding ​.
c​file that should contain the implementation.
The layers are:
Block layer (diskimg.[ch])
This defines and implements the interface for reading and writing sectors (note that the words block and sector are used interchangeably) on the disk image. We give you an implementation of this layer that should be sufficient for this assignment.
inode layer (inode.[ch])
This defines and implements the interface for reading the file system's inodes. This includes the ability to look up inodes by inumber and to get the block/sector number of the nth block of the inode's data.
File layer (file.[ch])
This defines and implements the interface for reading blocks of data from a file by specifying its inumber. This is one of the two layers our tests explicitly exercise.
Filename layer (directory.[ch])
This defines and implements the interface for implementing Unix directories on top of files. Its primary function is to get information about a single directory entry.
Pathname layer (pathname.[ch])
This defines and implements the interface to look up a file by its absolute pathname. This is the second of the two layers we explicitly test.

You are welcome to modify any of the files we give you. When making changes in the test harness, do so in a backward compatible way so that the testing scripts we give you continue to work. In other words, it's fine to add testing and debugging code, but make sure that when we run your program with ​-i ​and ​-p​, its output has the same format with or without your changes, so our automated tests won't break.
Before you try to write any code, you'll want to familiarize yourself with the details of the Unix V6 file system by reading 
Section 2.5 of the Saltzer and Kaashoek textbook. You may also find it helpful to read and understand how the test script works.


3:Suggestion

Suggested Implementation Order 
The starter code contains a number of unfinished functions. We suggest you attack them in the following order: 
*  inode_iget and inode_indexlookup in inode.c . 
*  file_getblock in file.c . After this step, your code should pass the inode level functionality tests. 
*  directory_findname in directory.c . 
*  pathname_lookup in pathname.c . Refer to Section 2.5.6 of the Salzer and Kaashoek book for this part. Afterward, all the pathname tests should pass. 


4:Grading
Code test results;
Clean build and clean ​valgrind ​reports;
Code quality: graded on bucket system [exceptional, solid, minor-problems, major-problems,etc.]

First, we'll run your code on a set of test disk images and check that your program gives the expected output. 
You have access to all of the images we'll use for grading and the correct output for each of them.
If this were a real archaeological dig, you would have been given only the disk image and a computer. But to make things easier,
we've provided you with starter code that tries to read all the files on the image and outputs ​checksums​ of the inode and file contents.
We've also computed these checksums using a working implementation of the assignment. If your checksums match ours, then your code 
is correctly reading the data off the disk.
Finally, we'll read through your code and give you comments on style and overall quality. We'll look for places where you 
inappropriately break the layering of the file system or make other mistakes that don't necessarily cause your program to generate
 the wrong output. We'll also look for common C programming errors such as memory leaks and use of the heap where stack allocation 
 is more appropriate. Finally, we'll check that your code is easy to read: It should be well-formatted, organized, and be easy 
 to follow.
